/**
 * Script de test PWA
 * V√©rifie que tous les fichiers PWA n√©cessaires sont pr√©sents
 */

import { access, readFile } from 'fs/promises';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const publicDir = join(__dirname, '..', 'public');

// Tests √† effectuer
const tests = {
  manifest: {
    name: 'Manifest.json',
    path: join(publicDir, 'manifest.json'),
    checks: async (content) => {
      const manifest = JSON.parse(content);
      const errors = [];
      
      if (!manifest.name) errors.push('‚ùå "name" manquant');
      if (!manifest.short_name) errors.push('‚ùå "short_name" manquant');
      if (!manifest.start_url) errors.push('‚ùå "start_url" manquant');
      if (!manifest.display) errors.push('‚ùå "display" manquant');
      if (!manifest.theme_color) errors.push('‚ùå "theme_color" manquant');
      if (!manifest.background_color) errors.push('‚ùå "background_color" manquant');
      if (!manifest.icons || manifest.icons.length === 0) {
        errors.push('‚ùå Aucune ic√¥ne d√©finie');
      }
      
      return errors;
    }
  },
  
  serviceWorker: {
    name: 'Service Worker',
    path: join(publicDir, 'sw.js'),
    checks: async (content) => {
      const errors = [];
      
      if (!content.includes('install')) errors.push('‚ùå Event "install" manquant');
      if (!content.includes('activate')) errors.push('‚ùå Event "activate" manquant');
      if (!content.includes('fetch')) errors.push('‚ùå Event "fetch" manquant');
      
      return errors;
    }
  },
  
  offlinePage: {
    name: 'Page Offline',
    path: join(publicDir, 'offline.html'),
    checks: async (content) => {
      const errors = [];
      
      if (!content.includes('<!DOCTYPE html>')) {
        errors.push('‚ùå HTML invalide');
      }
      
      return errors;
    }
  },
  
  icons: {
    name: 'Ic√¥nes PWA',
    paths: [
      join(publicDir, 'icons', 'icon-72x72.png'),
      join(publicDir, 'icons', 'icon-96x96.png'),
      join(publicDir, 'icons', 'icon-128x128.png'),
      join(publicDir, 'icons', 'icon-144x144.png'),
      join(publicDir, 'icons', 'icon-152x152.png'),
      join(publicDir, 'icons', 'icon-192x192.png'),
      join(publicDir, 'icons', 'icon-384x384.png'),
      join(publicDir, 'icons', 'icon-512x512.png'),
    ],
    checkMultiple: true
  }
};

/**
 * V√©rifie si un fichier existe
 */
async function fileExists(path) {
  try {
    await access(path);
    return true;
  } catch {
    return false;
  }
}

/**
 * Ex√©cute les tests
 */
async function runTests() {
  console.log('\nüß™ Tests PWA\n');
  console.log('‚ïê'.repeat(50) + '\n');
  
  let passed = 0;
  let failed = 0;
  let warnings = 0;
  
  for (const [key, test] of Object.entries(tests)) {
    console.log(`üìã ${test.name}`);
    
    if (test.checkMultiple) {
      // V√©rifier plusieurs fichiers
      const missing = [];
      
      for (const path of test.paths) {
        const exists = await fileExists(path);
        if (!exists) {
          const filename = path.split(/[/\\]/).pop();
          missing.push(filename);
        }
      }
      
      if (missing.length === 0) {
        console.log(`   ‚úÖ Toutes les ic√¥nes pr√©sentes (${test.paths.length})`);
        passed++;
      } else if (missing.length === test.paths.length) {
        console.log(`   ‚ùå Aucune ic√¥ne trouv√©e`);
        console.log(`   üí° Ex√©cutez: npm run generate-icons`);
        failed++;
      } else {
        console.log(`   ‚ö†Ô∏è  ${missing.length} ic√¥ne(s) manquante(s):`);
        missing.forEach(name => console.log(`      - ${name}`));
        warnings++;
      }
    } else {
      // V√©rifier un seul fichier
      const exists = await fileExists(test.path);
      
      if (!exists) {
        console.log(`   ‚ùå Fichier non trouv√©: ${test.path}`);
        failed++;
      } else {
        console.log(`   ‚úÖ Fichier pr√©sent`);
        
        if (test.checks) {
          const content = await readFile(test.path, 'utf-8');
          const errors = await test.checks(content);
          
          if (errors.length > 0) {
            console.log(`   ‚ö†Ô∏è  Probl√®mes d√©tect√©s:`);
            errors.forEach(err => console.log(`      ${err}`));
            warnings++;
          } else {
            console.log(`   ‚úÖ Validation r√©ussie`);
            passed++;
          }
        } else {
          passed++;
        }
      }
    }
    
    console.log();
  }
  
  // R√©sum√©
  console.log('‚ïê'.repeat(50));
  console.log('\nüìä R√©sum√©\n');
  console.log(`   ‚úÖ Tests r√©ussis:  ${passed}`);
  console.log(`   ‚ö†Ô∏è  Avertissements: ${warnings}`);
  console.log(`   ‚ùå Tests √©chou√©s:  ${failed}`);
  
  const total = passed + warnings + failed;
  const score = Math.round((passed / total) * 100);
  
  console.log(`\n   Score PWA: ${score}%`);
  
  if (score === 100) {
    console.log('\n   üéâ PWA pr√™te pour le d√©ploiement!\n');
  } else if (score >= 75) {
    console.log('\n   üëç Presque pr√™te, quelques ajustements n√©cessaires\n');
  } else {
    console.log('\n   ‚ö†Ô∏è  Des corrections importantes sont n√©cessaires\n');
  }
  
  // Prochaines √©tapes
  if (failed > 0 || warnings > 0) {
    console.log('üìã Prochaines √©tapes:\n');
    
    if (failed > 0) {
      console.log('   1. G√©n√©rer les ic√¥nes manquantes:');
      console.log('      npm run generate-icons\n');
    }
    
    if (warnings > 0) {
      console.log('   2. V√©rifier les fichiers avec avertissements');
      console.log('   3. Corriger les probl√®mes d√©tect√©s\n');
    }
  }
  
  console.log('üß™ Tests Lighthouse recommand√©s:\n');
  console.log('   1. Ouvrir DevTools (F12)');
  console.log('   2. Onglet "Lighthouse"');
  console.log('   3. Cocher "Progressive Web App"');
  console.log('   4. Cliquer "Generate report"\n');
  
  process.exit(score === 100 ? 0 : 1);
}

// Ex√©cuter les tests
runTests().catch(error => {
  console.error('‚ùå Erreur:', error);
  process.exit(1);
});
